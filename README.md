# lwrap
Line wrap text input according to user defined line width.

## Compile install and uninstall

* For linux/unix system:  
required header files:  
stdio.h  
stdlib.h  
unistd.h  
signal.h
```
Some of the following commands use sudo for install/uninstall.
> cd src/
> source lwrap.sh
> lwrap.config
> lwrap.make
> lwrap.install
> lwrap.uninstall
```
## Using lwrap
```
> man lwrap
```
   The most flexible way of using lwrap is to  
shifting with different line width inside vim  
with command, `:[range]!lwrap -jNUMBERS`.  
When you are satisfied, use this command to get final  
output, `:[range]!lwrap -jNUMBERS -e`

![Alt text](misc/lwrap.gif?raw=true "")

## Examples

* Output screen shots in different natural languages.

  lwrap support unicode utf-8 code page. The actual  
line width consistency depends on the input language  
font glyph width.

  The default line break is ASCII space plus newline,  
it makes the output reversible back to it's original  
input format. The reason is ASCII space occasionally  
been used as word and name separator in Asia  
languages, and if these spaces were erased, the output  
will no longer be reversible. The default can be  
changed with this command option, and it may be the  
desired final output.

![Alt text](misc/examples.gif?raw=true "")

## For developers

* Function structure

    One 256 elements struct array has been created. Each struct contains
function pointers, which in turn executes function to process unicode byte.

<img src="misc/structure.png" height="282" width="282">

    It seems we introduced a overhead by doing many function calls. 
But the benefits of decreased if-else cluster and increased maintainability 
of source code overcome some hundred milliseconds in lost speed efficiency. 
```
> wc big.txt
> 79594 568449 3525627 big.txt
> time lwrap -c80 -f big.txt >result1.txt
> real 0m0.079s
...
> time fmt -w 80 big.txt >result2.txt
> real 0m0.068s
```
* Control flow

<img src="misc/functions.png" height="282" width="282">

* Time line

  Three buffers been created for handling input bytes.  
We use library functions `fread` and `fwrite` to minimize  
the number of function calls. A short time delay been  
introduced for the first occurrence of line break.  
And another one for initiation of write buffer.  
The big "O" notation of input stream through  
the entire program is constant.

<img src="misc/timeline.png" height="232" width="382">


* Test cases

  A subset combination of line breaks and languages  
based on  reference text files been created for each  
test run.  
`coreutils` commands `diff`,`tr`,and `wc` been used to  
calculate and compare the total number of bytes from  
input stream with output generated by `lwrap`.  
`valgrind` and `gdb` been used for detecting memory leak  
and debugging the source code.  
`graphviz` or `dot` been used to generate graphs.  

* Coding style

  The most flexible way is keep your preferred coding style  
and use the following command for all of your source code  
before commit and change back to your preferred style  
after your checkout:  
`> indent --linux-style --indent-level4 --tab-size4 --line-length80 --no-tabs`
```
Or use this bash function:
> cd src/
> source lwrap.sh
> lwrap.indentall
```

* Releases

**beta** is the latest developing **branch**.
each **release** tag will be created from this **branch**.
e.g. **v1.0** is the first stable **release** tag form **beta** **branch**.

## Reporting a bug and security issues

github.com/netcrop/lwrap/pulls

## License

[GNU General Public License version 2 (GPLv2)](https://github.com/netcrop/lwrap/COPYING)
