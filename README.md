# lwrap
Line wrap text input according to user defined line width.

## Compile install and uninstall

* For linux/unix system:  
required header files:  
stdio.h  
stdlib.h  
unistd.h  
signal.h
```
Some of the following commands use sudo for install/uninstall.
> cd src/
> source lwrap.sh
> lwrap.config
> lwrap.make
> lwrap.install
> lwrap.uninstall
```
## Using lwrap
```
> man lwrap
```
   The most flexible way of using lwrap is to  
shifting with different line width inside vim  
with command, `:[range]!lwrap -jNUMBERS`.  
When you are satisfied, use this command to get final  
output, `:[range]!lwrap -jNUMBERS -e`

![Alt text](misc/lwrap.gif?raw=true "")

## Examples

* Output screenshots in different natural languages.

  lwrap support unicode utf-8 codepage. The actual  
line width consistency depends on the input language  
font glyph width.

  The default line break is ascii space plus newline,  
it makes the output reversible back to it's original  
input format. The reason is ascii space occasionally  
been used as word and name separator in asian  
languages, and if these spaces were erased, the output  
will no longer be reversible. The default can be  
changed with this command option, and it may be the  
desired final output.

![Alt text](misc/examples.gif?raw=true "")

## For developers

* Function calls

  One 255 elements array been created as a "filter" for each  
input byte. Each element is a struct pointer that pointing  
to one of 16 structs, which in turn contains functions that  
process each input byte.  
By doing this we avoid as many as possible if-else statements.  
And keep the functions in minimal size.

  The same filter applys for the last byte before each line  
break. This time the struct pointer will be resigned to execute
another function call.

  It seems we introduced a overhead by doing many function calls.
But the benefits of decreased if-else cluster and maintainability
of source code overcome some hundred millisecounds in lost speed 
efficiency.
```
> wc big.txt
> 79594 568449 3525627 big.txt
> time lwrap -c80 -f big.txt >result1.txt
> real 0m0.079s
...
> time fmt -w 80 big.txt >result2.txt
> real 0m0.068s
```

<img src="misc/functions.png" height="282" width="282">

* Timeline

  Three buffers been created for handling input bytes.  
We use library functions `fread` and `fwrite` to minimize  
the number of function calls. A short time delay been  
introduced for the first occurence of line break.  
And another one for initiation of write buffer.  
The big "O" notation of input stream through  
the entire program is constant.

<img src="misc/timeline.png" height="232" width="382">


* Test cases

  A subset combination of line breaks and languages  
based on  reference text files been created for each  
test run.  
`coreutils` commands `diff`,`tr`,and `wc` been used to  
calculate and compare the total number of bytes from  
input stream with output generated by `lwrap`.  
`valgrind` and `gdb` been used for detecting memory leak  
and debugging the source code.  
`graphviz` or `dot` been used to generate graphs.  

* Coding style

  The most flexible way is keep your preferred coding style  
and use the following command for all of your source code  
before commit and change back to your preferred style  
after your checkout:  
`> indent --linux-style --indent-level4 --tab-size4 --line-length80 --no-tabs`
```
Or use this bash function:
> cd src/
> source lwrap.sh
> lwrap.indentall
```

* Releases

**beta** is the latest developing **branch**.
each **release** tag will be created from this **branch**.
v[new features].[bugfix/security fix/documentation/API]  
e.g. **v1.0** is the first stable **release** tag form **beta** **branch**.

## Reporting a bug and security issues

github.com/netcrop/lwrap/issues

## License

[GNU General Public License version 2 (GPLv2)](https://github.com/netcrop/lwrap/COPYING)
